<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Project-47 language documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="forewords.html">Forewords</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Fundamental knowledges</li><li class="spacer"></li><li class="chapter-item expanded "><a href="cha1-terms-n-defs.html"><strong aria-hidden="true">1.</strong> Terms and definitions</a></li><li class="chapter-item expanded "><a href="cha2-lex-convs.html"><strong aria-hidden="true">2.</strong> Lexical conventions</a></li><li class="chapter-item expanded "><a href="cha3-prog-exec.html"><strong aria-hidden="true">3.</strong> Program execution</a></li><li class="chapter-item expanded affix "><li class="part-title">Entities and semantics</li><li class="spacer"></li><li class="chapter-item expanded "><a href="cha4-types.html"><strong aria-hidden="true">4.</strong> Types</a></li><li class="chapter-item expanded "><a href="cha5-id-scope.html"><strong aria-hidden="true">5.</strong> Identifiers and scopes</a></li><li class="chapter-item expanded "><a href="cha6-ffi.html"><strong aria-hidden="true">6.</strong> Foreign function interface</a></li><li class="chapter-item expanded "><a href="cha7-decls.html"><strong aria-hidden="true">7.</strong> Declarations</a></li><li class="chapter-item expanded "><a href="cha8-exprs.html"><strong aria-hidden="true">8.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="cha9-stmts.html"><strong aria-hidden="true">9.</strong> Statements</a></li><li class="chapter-item expanded "><a href="cha10-attrs.html"><strong aria-hidden="true">10.</strong> Attributes</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="app1-grammar.html">A. Grammar of Pr47</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Project-47 language documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#doc47---documentation-for-project-47-series" id="doc47---documentation-for-project-47-series">DOC47 - Documentation for Project-47 series</a></h1>
<p>S t a n d a r d   C o m m i t t e e   E m u l a t o r</p>
<h2><a class="header" href="#introduction-to-the-pr47-programming-language" id="introduction-to-the-pr47-programming-language">Introduction to the Pr47 programming language</a></h2>
<p><sup>1</sup>   <strong>Pr47 (47工程, Project-47, Проекта-47)</strong> is an extension language designed to support general procedural programming. Pr47 intends to be a powerful light-weight configuration language for Rust programs, while supporting seamless interaction with Rust environment.</p>
<p><sup>2</sup>   Pr47 intends to be a strict language, any operation violating Pr47 rules should be rejected and error will be thrown to host environment, either at compile time or at run time. A Pr47 implementation may also implement an optional tolerant mode, within which some of erroneous operations are allowed, and other erroneous operations are skipped without interrupting program execution. However, operations resulting undefined behavior are never legal and shall be avoided with every effort.</p>
<p><sup>3</sup>   This document is provided AS IS, WITHOUT ANY WARRANTY. If you find any bugs, typos or defects of this document, mail <a href="mailto://icey@icey.tech">ICEY(icey@icey.tech)</a>.</p>
<h2><a class="header" href="#1---terms-and-definitions---pr47terms" id="1---terms-and-definitions---pr47terms">1.   Terms and definitions   <code>[pr47.terms]</code></a></h2>
<ol>
<li><strong>Registration time</strong>: (phrase) the Pr47 implementation import foreign types and foreign functions from Rust host environment.</li>
<li><strong>Compile time</strong>: (phrase) the Pr47 implementation checks the program with certain static checking rules, and optionally transform source program into some optimized representation.</li>
<li><strong>Run time</strong>: (phrase) the Pr47 implementation executes the program and yield results.</li>
<li><strong>Well-formed</strong>: program does not violate Pr47 rules.</li>
<li><strong>Ill-formed</strong>: program not well formed.</li>
<li><strong>Reject</strong>: (compile time behavior) the Pr47 implementation refuses to run an ill-formed program, since it violates one or more piece of static rules.</li>
<li><strong>Undefined behavior</strong>: (runtime hehavior) result of operation is not defined, and should not be relied on.</li>
</ol>
<h2><a class="header" href="#2---lexical-conventions---pr47lex" id="2---lexical-conventions---pr47lex">2.   Lexical conventions   <code>[pr47.lex]</code></a></h2>
<blockquote>
<p>TODO: this section is incomplete</p>
</blockquote>
<h2><a class="header" href="#3---program-execution---pr47exec" id="3---program-execution---pr47exec">3.   Program execution   <code>[pr47.exec]</code></a></h2>
<p><sup>1</sup>   Pr47 is a semi-static programming language, due to which it combines static or compile time checks with dynamic or runtime checks. A Pr47 program is firstly compiled with certain static rules, and then executed with dynamic rules applied.</p>
<h3><a class="header" href="#31---initialization---pr47execinit" id="31---initialization---pr47execinit">3.1   Initialization   <code>[pr47.exec.init]</code></a></h3>
<p><sup>1</sup>   A Pr47 implementation may optionally have one or more initialization stages, which may initialize certain internal data and programs. Initialization, if present, should act like a normal Rust function or method.</p>
<h3><a class="header" href="#32---pr47-foreign-item-registration---pr47execreg" id="32---pr47-foreign-item-registration---pr47execreg">3.2   Pr47 foreign item registration   <code>[pr47.exec.reg]</code></a></h3>
<p><sup>1</sup>   After the Pr47 implementation gets initialized, foreign types and functions will be registered, so that they can be used in further program.</p>
<p><sup>2</sup>   Foreign types are registered first. Registering a foreign type is mostly about retrieving the type check informations of that type via <code>std::any::TypeId</code>, and then associate that information with a Pr47 identifier.</p>
<p><sup>3</sup>   A foreign function can be registered only after all its dependent foreign types get registered. Registing a Rust function mostly involves retrieving the function signature with assistance of <code>std::any::TypeId</code>, and then associate that information with a Pr47 identifier.</p>
<h3><a class="header" href="#34---compilation---pr47execcomp" id="34---compilation---pr47execcomp">3.4   Compilation   <code>[pr47.exec.comp]</code></a></h3>
<p><sup>1</sup>   After registing foreign types and functions, the Pr47 implementation then read in the Pr47 scripts, enforce the static checking rules, and optionally transform source codes into some optimized form. In a typical Pr47 implementation, the following steps may be taken in order.</p>
<p><sup>2</sup>   <em>Lexical analyzer</em> or <em>scanner</em> preprocesses the source code, removing any comment and redundant spaces, and produce a series of tokens.</p>
<p><sup>3</sup>   <em>Syntactical analyzer</em> or parser* parses the incoming token stream according to CFG definitions, optionally constructs a concrete syntax tree (CST) and passes it to next compiling stage.</p>
<p><sup>4</sup>   If supported, <em>compiler action applier</em> then applies <em>early compiler actions</em>, operates on the produced CST, performs several syntactical transformations and passes the updated CST to next compiling stage.</p>
<p><sup>5</sup>   <em>Semantic analyzer</em> analyzes the produced CST (if applicable), enforces static semantic rules, and optionally produces an abstract syntax tree (AST).</p>
<p><sup>6</sup>   If supported, <em>compiler action applier</em> then applies <em>late compiler actions</em>, operates on the produced AST, performs several semantical transformations and passes the updated AST to next stage.</p>
<p><sup>7</sup>   An optional <em>code generator</em> transforms the final AST (if applicable) to some intermediate form.</p>
<h3><a class="header" href="#35---function-export---pr47execexport" id="35---function-export---pr47execexport">3.5   Function export   <code>[pr47.exec.export]</code></a></h3>
<p><sup>1</sup>   After compilation, the Pr47 implementation should be able to export functions to host environment.</p>
<h3><a class="header" href="#36---program-execution---pr47execrun" id="36---program-execution---pr47execrun">3.6   Program execution   <code>[pr47.exec.run]</code></a></h3>
<p><sup1>1</sup>   It is possible to launch a single Pr47 function via the exported function interface. It is also possible to treat the whole script as an executable, and start execution from function <code>main</code>, <code>entry</code> or <code>application_start</code>. Only one of <code>main</code>, <code>entry</code> and <code>application_start</code> may be declared to global scope, and must satisfy the following signature:</p>
<pre><code class="language-go">func func_name() int
</code></pre>
<p>  or:</p>
<pre><code class="language-go">func func_name(vector&lt;string&gt;) int
</code></pre>
<h2><a class="header" href="#4---types---pr47type" id="4---types---pr47type">4.   Types   <code>[pr47.type]</code></a></h2>
<p><sup>1</sup>   Since Pr47 is semi-statically typed language, entities may be either statically type checked or dynamically type checked. A Pr47 implementation should use compile time information as much as possible to optimize program execution and provide better diagnostics.</p>
<h3><a class="header" href="#41---type-classifications---pr47typeclass" id="41---type-classifications---pr47typeclass">4.1   Type classifications   <code>[pr47.type.class]</code></a></h3>
<p><sup>1</sup>   There are two classes of types in Pr47: value types and reference types. Objects of value types comply copy semantics when assignment takes place, while objects of reference types comply clone (or shallow copy) semantics when assignment takes place. Foreign types registered from host environment are considered reference types.</p>
<h3><a class="header" href="#42---builtin-values-types---pr47typevalue" id="42---builtin-values-types---pr47typevalue">4.2   Builtin values types   <code>[pr47.type.value]</code></a></h3>
<p><sup>1</sup>   <strong>Integer</strong> type is denoted by keyword <code>int</code> and serves to represent integral numbers. Integer type should have the same representation with Rust <code>i64</code>.</p>
<p><sup>2</sup>   <strong>Float type</strong> is denoted by keyword <code>float</code> and serves to represent IEEE754 floating point numbers. Float type should have the same representation with Rust <code>f64</code>.</p>
<p><sup>3</sup>   <strong>Byte</strong> type is denoted by keyword <code>byte</code> and serves to represent a single byte. Byte type should have the same representation with Rust <code>u8</code>.</p>
<p><sup>4</sup>   <strong>Character</strong> type is denoted by keyword <code>char</code> and serves to represent a unicode character. Char type should have the same representation with Rust <code>char</code>.</p>
<p><sup>5</sup>   <strong>Boolean</strong> type is denoted by keyword <code>bool</code> and serves to represent a binary <code>true</code> or <code>false</code>. Boolean type should have the same representation with Rust <code>bool</code>.</p>
<h3><a class="header" href="#43---builtin-reference-types---pr47typeref" id="43---builtin-reference-types---pr47typeref">4.3   Builtin reference types   <code>[pr47.type.ref]</code></a></h3>
<p><sup>1</sup>   <strong>String</strong> type is denoted by keyword <code>string</code> and serves to represent any UTF-8 text. String type should have the same representation with Rust <code>std::string::String</code>.</p>
<p><sup>2</sup>   <strong>Vector</strong> or <strong>dynamic array</strong> type is denoted by keyword <code>vector</code> and serves to represent a variable length array. <code>vector</code> is a generic container. See grammar and example.</p>
<blockquote>
<p>grammar of vector type</p>
<pre><code class="language-plaintext">    vector-type ::= &quot;vector&quot; &quot;&lt;&quot; type &quot;&gt;&quot;
</code></pre>
</blockquote>
<pre><code class="language-go">    var v vector&lt;int&gt; = new_vec();
    v.push(1);      // now v = [1]
    v.insert(0, 2); // now v = [2, 1]
    v.push(2.5);    // ill-formed, v is an vector of int
</code></pre>
<p><sup>3</sup>   The vector type should have a corresponding Rust representation, so that it can be used by Pr47 type fusion.</p>
<blockquote>
<p><sup>4</sup>   <strong>object</strong> type</p>
<p><sup>5</sup>   <strong>any</strong> type</p>
</blockquote>
<h3><a class="header" href="#44---foreign-types---pr47typeforeign" id="44---foreign-types---pr47typeforeign">4.4   Foreign types   <code>[pr47.type.foreign]</code></a></h3>
<blockquote>
<p>TODO</p>
</blockquote>
<h3><a class="header" href="#45---type-fusion---pr47typefusion" id="45---type-fusion---pr47typefusion">4.5   Type fusion   <code>[pr47.type.fusion]</code></a></h3>
<blockquote>
<p>TODO</p>
</blockquote>
<h2><a class="header" href="#5---identifiers-and-scopes---pr47scope" id="5---identifiers-and-scopes---pr47scope">5.   Identifiers and scopes   <code>[pr47.scope]</code></a></h2>
<p><sup>1</sup>   An identifier can denote an object; a function; a member of an object or a member of a foreign transparent structure. For each different entity that an identifer designates, the identifier is visible only wthin a region of program text called scope.</p>
<p><sup>2</sup>   There are two kinds of scope in Pr47: global scope and block scope. Identifiers introduced into global scope are valid in any context of a Pr47 program, while identifiers introduced into a block scope are only valid in that block after the introduction point. An identifier should not be introduced to the same scope twice. See example.</p>
<pre><code class="language-go">// v1 introduced to global scope, valid in global, functions f1 and f2
var v1 = 5;
var v2 = f1(v1); // valid

// f1 introduced to global scope, valid in global, functions f1 and f2
// parameter v3 introduced to function f1 scope, only valid in f1
func f1 (v3) {
	v4 = 6; // invalid, v4 not introduced yet.

	var v3 = 13; // invalid, v3 already introduced (as a parameter)
	// v4 introduced to function f1 scope, only valid in f1
	var v4 = 191;

	v1 = 19; // valid
	f2(); // valid

	{ // 'a
		// v5 introduced to 'a scope, valid in 'a
		var v5 = 5;
	}
	v5 = 66; // invalid
}

// f2 introduced to global scope, valid in global, functions f1 and f2
func f2 () {
	f1(); // valid
	v2 = 42; // valid
	v3 = 42; // invalid, v3 is local to f1
	v4 = 42; // invalid, v4 is local to f1
}

var f1 = 130; // invalid, f1 already introduced (as a function)
</code></pre>
<p><sup>3</sup>   One identifier can be introduced to more than one block scopes. Same identifiers in different block scopes are isolated. See example.</p>
<pre><code class="language-go">// block 'a
func f1 () {
	var v int = 5; // A variable v of type int introduced to 'a
}

// block 'b
func f2 () {
	var v string = &quot;5&quot;; // A variable v of type str introduced to 'b

	// block 'c
	{
		var v2 float = 1.9; // A variable v2 of type float introduced to 'c
	}

	// block 'd
	{
		var v2 int = 42; // A variable v2 of type float introduced to 'd
	}
</code></pre>
<p><sup>4</sup>   One identifier can be introduced to two nested scopes. In this case identifiers introduced to the inner scope will shadow the identifier introduced to the outer scope. To use the global identifier explicitly, use global:name. See example.</p>
<pre><code class="language-go">var v1 = 43;

// block 'a
func f1() {
	v1.print(); // access global v1
}

// block 'b
func f2() {
	var v1 = 14; // shadowing global v1
	v1.print();  // access local 'b v1
	// block 'c
	{
		var v1 = &quot;19&quot;; // shadowing 'b v1
		v1.print(); // access local 'c v1
	}
	global:v1.print(); // access global v1 using global: specifier
}
</code></pre>
<h2><a class="header" href="#6---foreign-function-interface---pr47ffi" id="6---foreign-function-interface---pr47ffi">6.   Foreign function interface   <code>[pr47.ffi]</code></a></h2>
<p><sup>1</sup>   A Pr47 program is able to use Rust types, call Rust functions or export functions to Rust via Pr47 foreign function interace (FFI).</p>
<h3><a class="header" href="#61---binding-rust-type-pr47ffitype" id="61---binding-rust-type-pr47ffitype">6.1   Binding Rust type <code>[pr47.ffi.type]</code></a></h3>
<p><sup>1</sup>   An implementation must be able to register any Rust type <code>T: 'static</code> and bind that type to a Pr47 identifier. Bounded type can then be used in Pr47 program via that appointed identifier.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // pseudo code, implementation does not have to be in this way
    // binding Rust type T to Pr47 identifier a.b.T
    pr47_instance.bind_type::&lt;T&gt;(&quot;a.b.T&quot;);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-go">    import a.b.T;

    func foo(t T) { /* ... */ }
    func bar() T { /* ... */ }
</code></pre>
<p><sup>2</sup>   An implementation may optionally implement a registering mechanism for <code>T: 'a</code>. Restrictions and semantics are implementation defined, and suggested to be coherent with <code>T: 'static</code>.</p>
<p><sup>3</sup>   Redefining any registered type is considered ill-formed. Registering a type twice is considered ill-formed. Registering types already handled in type fusion rulesis is considered ill-formed.</p>
<h3><a class="header" href="#62---binding-rust-function-pr47ffifunc" id="62---binding-rust-function-pr47ffifunc">6.2   Binding Rust function <code>[pr47.ffi.func]</code></a></h3>
<p><sup>1</sup>   An implementation must be able to register any Rust function whose parameter types satisfy one of the following rules:</p>
<ul>
<li><code>T: 'static</code></li>
<li><code>&amp;'a T</code> or <code>&amp;'a mut T</code>, where <code>'a</code> outlives the lifetime of the Pr47 instance (if applicable), and <code>T: 'static</code></li>
<li><code>Option&lt;T&gt;</code>, where <code>T</code> satisfies one of the two rules above</li>
</ul>
<p>  and return type satisfies one of the following rules:</p>
<ul>
<li><code>T: 'static</code></li>
<li><code>&amp;'a T</code> or <code>&amp;'a mut T</code>, where <code>'a</code> outlives the lifetime of the Pr47 instance (if applicable), and <code>T: 'static</code></li>
<li><code>Option&lt;T&gt;</code>, where <code>T</code> satisfies one of the two rules above</li>
<li><code>&amp;'a Option&lt;T&gt;</code> or <code>&amp;'a mut Option&lt;T&gt;</code>, where <code>'a </code> outlives the lifetime of the Pr47 instance (if applicable), and <code>T: 'static</code></li>
<li><code>Result&lt;T, E&gt;</code>, where <code>T</code> satisfies one of the four rules above, and <code>E: 'static + std::error::Error</code></li>
</ul>
<p><sup>2</sup>   The implementation should perform the following automatic operations for function arguments:</p>
<ul>
<li>for parameter with <code>Option</code> type, convert <code>null</code> value to <code>None</code> variant, and convert non-<code>null</code> value to <code>Some</code> variant according to the following four rules</li>
<li>for parameter with <code>&amp;'a T</code> type, share Pr47 object with Rust environment</li>
<li>for parameter with <code>&amp;'a mut T</code> type, mutably share Pr47 object with Rust environment</li>
<li>for parameter with <code>T: Copy</code> type, copy the Pr47 object to Rust environment</li>
<li>otherwise, move the Pr47 object to Rust environment</li>
</ul>
<p><sup>3</sup>   The implementation should perform the following automatic operations for function return value, step by step:</p>
<ul>
<li>for return value with <code>Result&lt;T, E&gt;</code> type, convert <code>Err</code> variant to a Pr47 exception, and convert <code>Ok</code> variant according to the following five rules</li>
<li>for return value with <code>&amp;'a Option&lt;T&gt;</code> type, convert it to <code>Option&lt;&amp;'a T&gt;</code>; and for <code>&amp;'a mut Option&lt;T&gt;</code>, convert it to <code>Option&lt;&amp;'a mut T&gt;</code></li>
<li>for return value with <code>Option&lt;T&gt;</code> type, convert <code>None</code> variant to <code>null</code> value, and convert <code>Some</code> variant according to the following three rules</li>
<li>for return value with <code>&amp;'a T</code> type, share that value with Rust environment</li>
<li>for return value with <code>&amp;'a mut T</code> type, mutably share that value with Rust environment</li>
<li>otherwise, move that value to Pr47</li>
</ul>
<h3><a class="header" href="#63---exporting-pr47-function-pr47ffiexport" id="63---exporting-pr47-function-pr47ffiexport">6.3   Exporting Pr47 function <code>[pr47.ffi.export]</code></a></h3>
<h2><a class="header" href="#7---declarations---pr47decl" id="7---declarations---pr47decl">7.   Declarations   <code>[pr47.decl]</code></a></h2>
<p><sup>1</sup>   A declaration may introduce a variable or function into a specific scope.</p>
<h3><a class="header" href="#71---variable-declaration---pr47declvar" id="71---variable-declaration---pr47declvar">7.1   Variable declaration   <code>[pr47.decl.var]</code></a></h3>
<blockquote>
<p>grammer of variable declaration</p>
<pre><code class="language-plaintext">var-decl ::= &quot;var&quot; identifier var-decl-type var-opt-init

var-decl-type ::=
      type
    | &quot;deduced&quot;
    | &quot;&quot;

var-opt-init ::=
      &quot;=&quot; expr
    | &quot;&quot;
</code></pre>
</blockquote>
<p><sup>1</sup>   A variable declaration introduces a variable to its scope. If a variable declaration occurs in a block, then then the variable is introduced to that block scope; otherwise to the global scope.</p>
<p><sup>2</sup>   A typed variable declaration introduces a variable of specific type to scope. The introduced variable is called <em>typed variable</em>. A typed variable can only be assigned with object of that type. See exmple.</p>
<pre><code class="language-go">var a int = 42; // a is of int type
a = 5.56; // ill-formed, type mismatch
var b int = 'д'; // ill-formed, type mismatch
</code></pre>
<p><sup>3</sup>   An untyped variable declaration introduces a variable of uncertain type to scope. The introduced variable is called <em>untyped variable</em>. An untyped variable can be assigned with object of any type. Concrete type of the object denoted by the variable may change as new object gets assigned to the variable. See example.</p>
<pre><code class="language-go">var a = 54; // a is of int type now
a = 'c'; // a is of char type now
a = &quot;Здравствуйте&quot; // a is of string type now
</code></pre>
<p><sup>4</sup>   A variable can be declared with <code>deduced</code> type. Variables with deduced type are considered typed variables, whose type is automatically deduced from its initializer. Initializer evaluates to value <code>null</code> is ill formed.</p>
<pre><code class="language-go">var a deduced = 5; // a deduced to be int
var b deduced = &quot;привет&quot;; // b deduced to be string
var c deduced = null; // ill-formed
</code></pre>
<h3><a class="header" href="#72---function-declaration---pr47declfunc" id="72---function-declaration---pr47declfunc">7.2   Function declaration   <code>[pr47.decl.func]</code></a></h3>
<blockquote>
<p>grammar of function declaration</p>
<pre><code class="language-plaintext">function-decl ::= &quot;func&quot; identifier &quot;(&quot; param-list &quot;)&quot; opt-type opt-func-body

opt-func-body ::= 
      &quot;;&quot;
    | compound-stmt

opt-type ::=
      type
    | &quot;&quot;
</code></pre>
</blockquote>
<p><sup>1</sup>   A function declaration may have an optional function body, a compound statement. A function declaration with a body is called a <em>function definition</em>. A function declaration without a body may serve an attribute provider.</p>
<h3><a class="header" href="#721---function-parameters---pr47declfuncparm" id="721---function-parameters---pr47declfuncparm">7.2.1   Function parameters   <code>[pr47.decl.func.parm]</code></a></h3>
<blockquote>
<p>grammar of function parameter</p>
<pre><code class="language-plaintext">param-list ::= 
      param-list &quot;,&quot; param
    | param
    | &quot;&quot;

param ::= identifier opt-type
</code></pre>
</blockquote>
<p><sup>1</sup>   A function may optionally take a series of parameters. A function parameter may be explicitly marked with a type, such parameters are called <em>typed parameters</em>. Parameters that are not a typed parameters are called <em>untyped parameters</em>.</p>
<h2><a class="header" href="#8-expressions---pr47expr" id="8-expressions---pr47expr">  8. Expressions   <code>[pr47.expr]</code></a></h2>
<h2><a class="header" href="#9-statements---pr47stmt" id="9-statements---pr47stmt">  9. Statements   <code>[pr47.stmt]</code></a></h2>
<h2><a class="header" href="#10-attributes---pr47attr" id="10-attributes---pr47attr">  10. Attributes   <code>[pr47.attr]</code></a></h2>
<p><sup>1</sup>   An attribute, by itself, does not have any semantics. Attributes are read by compiler actions who're able to transform the source program at syntax or semantic layer.</p>
<blockquote>
<p>grammar of global attributes</p>
<pre><code class="language-plaintext">global-attrs ::= 
       global-attrs global-attr
     | &quot;&quot;

global-attr ::= &quot;#![&quot; attr-list &quot;]&quot;
</code></pre>
</blockquote>
<p><sup>2</sup>   Global attributes can be added to the commence of a Pr47 source file.</p>
<blockquote>
<p>grammar of attributed item</p>
<pre><code class="language-plaintext">attr-decl ::=
      attr decl
    | decl

attr-stmt ::=
      attr stmt
    | stmt

attr ::= &quot;#[&quot; attr-list &quot;]&quot;
</code></pre>
</blockquote>
<p><sup>3</sup>   Each declaration or statement in Pr47 may be prefixed with an attribute declarator.</p>
<blockquote>
<p>grammar of attribute</p>
<pre><code class="language-plaintext">attr-list ::= 
      attr-list &quot;,&quot; attr-body
    | attr-body
    | &quot;&quot;

attr-body ::= 
      single-id-attr
    | single-value-attr
    | kv-pair-attr

single-id-attr ::= identifier
kv-pair-attr   ::= identifier &quot;=&quot; attr-body
call-like-attr ::= identifier &quot;(&quot;  attr-list &quot;)&quot;
</code></pre>
</blockquote>
<p><sup>4</sup>   An attribute may be a single identifier attribute, a key-value like attribute or a function call like attribute.</p>
<h3><a class="header" href="#101-compiler-actions---pr47attract" id="101-compiler-actions---pr47attract">  10.1 Compiler actions   <code>[pr47.attr.act]</code></a></h3>
<p><sup>1</sup>   A compiler action is a Rust object consists of a name, an attribute <em>recognizer</em> and a series of transformation. A compiler action may be either an <em>early compiler action</em> that acts on syntactical layer, or a <em>late compiler action</em> that acts on semantical layer. Concrete representation and grammar of compiler actionares implementation defined.</p>
<p><sup>2</sup>   Pr47 implementation matches the recognizer of compiler action and each attribute in <em>top level attribute list</em> in the following way:</p>
<ul>
<li>For single identifier attribute, the compiler action and attribute match if the identifier and recognizer match</li>
<li>For key-value like attribute, the compiler action and attribute match if the key part of that attribute and recognizer match</li>
<li>For function call like attribute, the compiler action and attribute match if the <em>function name part</em> of that attribute and recognizer match.</li>
</ul>
<p>  See example.</p>
<pre><code class="language-go">#[force_static,    // attr1, may match with compiler action &quot;force_static&quot;
  repr=&quot;C&quot;,        // attr2, may match with compiler action &quot;repr&quot;
  proof(postulate) // attr3, may match with compiler action &quot;proof&quot;
]
func foo() {}
</code></pre>
<p><sup>3</sup>   Once a compiler action matches with an attribute, the attribute arguments (if present) together with the attributed item (the whole translation unit for global attributes) are then sent to the transformation code. See example.</p>
<pre><code class="language-go">// Here, the attribut list [result, T, E], together with the function
// itself &quot;func bar() {}&quot; are sent to compiler action &quot;error_chain&quot;
#[error_chain(result, T, E)]
func bar() {}
</code></pre>
<h2><a class="header" href="#a-full-grammer-of-pr47" id="a-full-grammer-of-pr47">A. full grammer of Pr47</a></h2>
<pre><code class="language-plaintext">program ::= global-attrs attr-decls

global-attrs ::= 
      global-attrs global-attr
    | &quot;&quot;

attr-decls ::=
      attr-decls attr-decl
    | &quot;&quot;

global-attr ::= &quot;#![&quot; attr-list &quot;]&quot;

attr-decl ::=
      attr decl
    | decl

attr ::= &quot;#[&quot; attr-list &quot;]&quot;

decl ::= 
      function-decl
    | var-decl

function-decl ::= &quot;func&quot; identifier &quot;(&quot; param-list &quot;)&quot; opt-type opt-func-body

var-decl ::= &quot;var&quot; identifier var-decl-type var-opt-init

var-decl-type ::=
      type
    | &quot;deduced&quot;
    | &quot;&quot;

var-opt-init ::=
      &quot;=&quot; expr
    | &quot;&quot;

param-list ::= 
      param-list &quot;,&quot; param
    | param
    | &quot;&quot;

param ::= identifier opt-type

opt-func-body ::= 
      &quot;;&quot;
    | compound-stmt

opt-type ::=
      type
    | &quot;&quot;

attr-list ::= 
      attr-list &quot;,&quot; attr-body
    | attr-body
    | &quot;&quot;

attr-body ::= 
      single-id-attr
    | single-value-attr
    | kv-pair-attr
    | call-like-attr

single-id-attr    ::= identifier
kv-pair-attr      ::= identifier &quot;=&quot; attr-body
call-like-attr    ::= identifier &quot;(&quot;  attr-list &quot;)&quot;

attr-value ::=
      int-lit
    | char-lit
    | bool-lit
    | str-lit
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
